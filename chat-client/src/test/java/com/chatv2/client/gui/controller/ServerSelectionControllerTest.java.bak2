package com.chatv2.client.gui.controller;

import com.chatv2.client.core.ChatClient;
import com.chatv2.client.discovery.ServerDiscovery;
import com.chatv2.client.discovery.ServerInfo;
import com.chatv2.client.gui.ChatClientApp;
import javafx.application.Platform;
import javafx.collections.ObservableList;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.ListView;
import javafx.scene.control.RadioButton;
import javafx.scene.control.TextField;
import javafx.scene.layout.VBox;
import javafx.stage.Stage;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.testfx.framework.junit5.ApplicationExtension;

import java.lang.reflect.Field;
import java.util.Timer;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

/**
 * Тест для проверки исправления проблемы с постоянным поиском серверов
 * Проверяет, что таймер останавливается при переключении на другие экраны
 * и запускается при возврате на экран выбора сервера
 */
@ExtendWith({ApplicationExtension.class, MockitoExtension.class})
class ServerSelectionControllerTest {

    @Mock
    private ChatClient mockChatClient;

    @Mock
    private ServerDiscovery mockServerDiscovery;

    @Mock
    private ChatClientApp mockChatClientApp;

    private ServerSelectionController controller;
    private Stage stage;

    @BeforeEach
    void setUp() throws Exception {
        // Инициализируем JavaFX Platform
        CountDownLatch latch = new CountDownLatch(1);
        Platform.startup(() -> latch.countDown());
        if (!latch.await(5, TimeUnit.SECONDS)) {
            throw new RuntimeException("Timeout waiting for JavaFX platform startup");
        }

        // Создаем контроллер
        controller = new ServerSelectionController();
        
        // Мокаем вызовы к ChatClientApp
        when(mockChatClientApp.getChatClient()).thenReturn(mockChatClient);
        when(mockChatClientApp.getServerDiscovery()).thenReturn(mockServerDiscovery);
        
        // Устанавливаем мок через рефлексию
        Field instanceField = ChatClientApp.class.getDeclaredField("instance");
        instanceField.setAccessible(true);
        instanceField.set(null, mockChatClientApp);
        
        // Настраиваем поведение для ServerDiscovery
        when(mockServerDiscovery.startDiscovery()).thenReturn CompletableFuture.completedFuture(null));
        when(mockServerDiscovery.getDiscoveredServers()).thenReturn(java.util.Collections.emptyList());
    }

    @AfterEach
    void tearDown() throws Exception {
        // Останавливаем таймер, если он был запущен
        if (controller != null) {
            controller.cleanup();
        }
        
        // Сбрасываем мок ChatClientApp
        Field instanceField = ChatClientApp.class.getDeclaredField("instance");
        instanceField.setAccessible(true);
        instanceField.set(null, null);
    }

    @Test
    @DisplayName("Should start auto-refresh timer in auto-discovery mode")
    void testStartAutoRefreshInAutoDiscoveryMode() throws Exception {
        // Запускаем инициализацию на JavaFX потоке
        CountDownLatch latch = new CountDownLatch(1);
        Platform.runLater(() -> {
            try {
                controller.initialize(null, null);
                latch.countDown();
            } catch (Exception e) {
                e.printStackTrace();
                latch.countDown();
            }
        });
        
        assertTrue(latch.await(5, TimeUnit.SECONDS), "Timeout waiting for initialization");
        
        // Проверяем, что таймер был запущен
        Timer timer = getPrivateField(controller, "refreshTimer");
        assertNotNull(timer, "Auto-refresh timer should be started in auto-discovery mode");
    }

    @Test
    @DisplayName("Should stop auto-refresh timer when switching to manual mode")
    void testStopAutoRefreshInManualMode() throws Exception {
        // Инициализируем контроллер
        CountDownLatch initLatch = new CountDownLatch(1);
        Platform.runLater(() -> {
            try {
                controller.initialize(null, null);
                initLatch.countDown();
            } catch (Exception e) {
                e.printStackTrace();
                initLatch.countDown();
            }
        });
        
        assertTrue(initLatch.await(5, TimeUnit.SECONDS), "Timeout waiting for initialization");
        
        // Переключаемся в ручной режим
        CountDownLatch modeLatch = new CountDownLatch(1);
        Platform.runLater(() -> {
            try {
                // Мокаем RadioButton для ручного режима
                RadioButton manualRadio = new RadioButton("Manual");
                RadioButton autoRadio = new RadioButton("Auto");
                autoRadio.setSelected(false);
                manualRadio.setSelected(true);
                
                // Устанавливаем радио-кнопки через рефлексию
                setPrivateField(controller, "manualInputRadio", manualRadio);
                setPrivateField(controller, "autoDiscoveryRadio", autoRadio);
                
                // Вызываем метод переключения режима
                controller.handleDiscoveryModeChange();
                modeLatch.countDown();
            } catch (Exception e) {
                e.printStackTrace();
                modeLatch.countDown();
            }
        });
        
        assertTrue(modeLatch.await(5, TimeUnit.SECONDS), "Timeout waiting for mode change");
        
        // Проверяем, что таймер был остановлен
        Timer timer = getPrivateField(controller, "refreshTimer");
        assertNull(timer, "Auto-refresh timer should be stopped in manual mode");
    }

    @Test
    @DisplayName("Should restart auto-refresh timer when switching back to auto-discovery mode")
    void testRestartAutoRefreshWhenSwitchingBackToAutoMode() throws Exception {
        // Инициализируем контроллер
        CountDownLatch initLatch = new CountDownLatch(1);
        Platform.runLater(() -> {
            try {
                controller.initialize(null, null);
                initLatch.countDown();
            } catch (Exception e) {
                e.printStackTrace();
                initLatch.countDown();
            }
        });
        
        assertTrue(initLatch.await(5, TimeUnit.SECONDS), "Timeout waiting for initialization");
        
        // Сначала переключаемся в ручной режим
        CountDownLatch manualLatch = new CountDownLatch(1);
        Platform.runLater(() -> {
            try {
                // Мокаем RadioButton для ручного режима
                RadioButton manualRadio = new RadioButton("Manual");
                RadioButton autoRadio = new RadioButton("Auto");
                autoRadio.setSelected(false);
                manualRadio.setSelected(true);
                
                // Устанавливаем радио-кнопки через рефлексию
                setPrivateField(controller, "manualInputRadio", manualRadio);
                setPrivateField(controller, "autoDiscoveryRadio", autoRadio);
                
                // Вызываем метод переключения режима
                controller.handleDiscoveryModeChange();
                manualLatch.countDown();
            } catch (Exception e) {
                e.printStackTrace();
                manualLatch.countDown();
            }
        });
        
        assertTrue(manualLatch.await(5, TimeUnit.SECONDS), "Timeout waiting for manual mode switch");
        
        // Проверяем, что таймер был остановлен
        Timer timer = getPrivateField(controller, "refreshTimer");
        assertNull(timer, "Auto-refresh timer should be stopped in manual mode");
        
        // Теперь переключаемся обратно в авто-режим
        CountDownLatch autoLatch = new CountDownLatch(1);
        Platform.runLater(() -> {
            try {
                RadioButton manualRadio = new RadioButton("Manual");
                RadioButton autoRadio = new RadioButton("Auto");
                autoRadio.setSelected(true);
                manualRadio.setSelected(false);
                
                // Устанавливаем радио-кнопки через рефлексию
                setPrivateField(controller, "manualInputRadio", manualRadio);
                setPrivateField(controller, "autoDiscoveryRadio", autoRadio);
                
                // Вызываем метод переключения режима
                controller.handleDiscoveryModeChange();
                autoLatch.countDown();
            } catch (Exception e) {
                e.printStackTrace();
                autoLatch.countDown();
            }
        });
        
        assertTrue(autoLatch.await(5, TimeUnit.SECONDS), "Timeout waiting for auto mode switch");
        
        // Проверяем, что таймер был перезапущен
        timer = getPrivateField(controller, "refreshTimer");
        assertNotNull(timer, "Auto-refresh timer should be restarted when switching back to auto mode");
    }

    @Test
    @DisplayName("Should stop auto-refresh timer on cleanup")
    void testStopAutoRefreshOnCleanup() throws Exception {
        // Инициализируем контроллер
        CountDownLatch initLatch = new CountDownLatch(1);
        Platform.runLater(() -> {
            try {
                controller.initialize(null, null);
                initLatch.countDown();
            } catch (Exception e) {
                e.printStackTrace();
                initLatch.countDown();
            }
        });
        
        assertTrue(initLatch.await(5, TimeUnit.SECONDS), "Timeout waiting for initialization");
        
        // Проверяем, что таймер был запущен
        Timer timer = getPrivateField(controller, "refreshTimer");
        assertNotNull(timer, "Auto-refresh timer should be started initially");
        
        // Вызываем cleanup
        CountDownLatch cleanupLatch = new CountDownLatch(1);
        Platform.runLater(() -> {
            try {
                controller.cleanup();
                cleanupLatch.countDown();
            } catch (Exception e) {
                e.printStackTrace();
                cleanupLatch.countDown();
            }
        });
        
        assertTrue(cleanupLatch.await(5, TimeUnit.SECONDS), "Timeout waiting for cleanup");
        
        // Проверяем, что таймер был остановлен
        timer = getPrivateField(controller, "refreshTimer");
        assertNull(timer, "Auto-refresh timer should be stopped after cleanup");
    }

    @Test
    @DisplayName("Should not start multiple timers when startAutoRefresh is called multiple times")
    void testMultipleStartAutoRefreshCalls() throws Exception {
        // Инициализируем контроллер
        CountDownLatch initLatch = new CountDownLatch(1);
        Platform.runLater(() -> {
            try {
                controller.initialize(null, null);
                initLatch.countDown();
            } catch (Exception e) {
                e.printStackTrace();
                initLatch.countDown();
            }
        });
        
        assertTrue(initLatch.await(5, TimeUnit.SECONDS), "Timeout waiting for initialization");
        
        // Получаем первоначальный таймер
        Timer initialTimer = getPrivateField(controller, "refreshTimer");
        assertNotNull(initialTimer, "Auto-refresh timer should be started initially");
        
        // Вызываем startAutoRefresh еще раз
        CountDownLatch startLatch = new CountDownLatch(1);
        Platform.runLater(() -> {
            try {
                controller.startAutoRefresh();
                startLatch.countDown();
            } catch (Exception e) {
                e.printStackTrace();
                startLatch.countDown();
            }
        });
        
        assertTrue(startLatch.await(5, TimeUnit.SECONDS), "Timeout waiting for startAutoRefresh");
        
        // Проверяем, что используется тот же таймер
        Timer secondTimer = getPrivateField(controller, "refreshTimer");
        assertSame(initialTimer, secondTimer, "Should use the same timer instance, not create a new one");
    }

    @Test
    @DisplayName("Should handle null timer gracefully in stopAutoRefresh")
    void testStopAutoRefreshWithNullTimer() throws Exception {
        // Устанавливаем таймер в null через рефлексию
        setPrivateField(controller, "refreshTimer", null);
        
        // Вызываем stopAutoRefresh - не должно быть исключений
        CountDownLatch latch = new CountDownLatch(1);
        Platform.runLater(() -> {
            try {
                controller.stopAutoRefresh();
                latch.countDown();
            } catch (Exception e) {
                e.printStackTrace();
                latch.countDown();
            }
        });
        
        assertTrue(latch.await(5, TimeUnit.SECONDS), "Timeout waiting for stopAutoRefresh");
        
        // Проверяем, что таймер все еще null
        Timer timer = getPrivateField(controller, "refreshTimer");
        assertNull(timer, "Timer should remain null");
    }

    /**
     * Вспомогательный метод для получения приватного поля через рефлексию
     */
    @SuppressWarnings("unchecked")
    private <T> T getPrivateField(Object obj, String fieldName) throws Exception {
        Field field = obj.getClass().getDeclaredField(fieldName);
        field.setAccessible(true);
        return (T) field.get(obj);
    }

    /**
     * Вспомогательный метод для установки приватного поля через рефлексию
     */
    private void setPrivateField(Object obj, String fieldName, Object value) throws Exception {
        Field field = obj.getClass().getDeclaredField(fieldName);
        field.setAccessible(true);
        field.set(obj, value);
    }
}